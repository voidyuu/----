## 单一连续分配

内存被分为**系统区和用户区**，系统区仅供操作系统使用，通常在**低地址**部分；用户区**仅有一道**用户程序，即用户程序独占整个用户区。

## 固定分区分配

将用户内存空间划分为若干固定大小的分区，每个分区只装入一道作业。

划分分区有两种方法：

1. 分区大小相等。程序太小会造成浪费，程序太大又无法装入，缺乏灵活性
2. 分区大小不等。划分为多个较小的分区、适量的中等分区和少量大分区

![](https://img.mileomni.com/1731242874480.png)

## 动态分区分配

### 动态分区分配的基本原理

![](https://img.mileomni.com/1731242874514.png)

外部碎片非常多。可以通过**紧凑技术**来克服，但是需要**动态重定位寄存器**的支持且相对费时

### 基于顺序搜索的分配算法

#### 首次适应 (First Fit) 算法

空闲分区按**地址递增**的次序排列。每次分配内存时，顺序查找到第一个能满足大小的空闲分区，分配给作业。

#### 邻近适应 (Next Fit) 算法

也称**循环首次适应算法**，由首次适应算法演变而成。不同的是，分配内存时从上次查找结束的位置开始继续查找。**通常比首次适应算法更差**。

#### 最佳适应 (Best Fit) 算法

空闲分区按**容量递增**的次序排列。每次分配内存时，顺序查找到**最小的能满足大小的空闲分区**，分配给作业。性能很差，因为每次分配会留下越来越多很小的难以利用的内存块，进而产生**最多的**外部碎片。

#### 最坏适应 (Worst Fit) 算法

空闲分区按**容量递减**的次序排列。每次分配内存时，顺序查找到**最大的能满足大小的空闲分区**，分配给作业。**会很快消耗大的空闲分区，因此性能也很差**。

### 基于索引搜索的分配算法

根据其大小对空闲分区分类，对于每类（大小相同）空闲分区，单独设立一个空闲分区链，并设置一张**索引表来管理这些空闲分区链**。

#### 快速适应算法

1. 先根据进程的长度，在索引表中找到能容纳它的**最小**空闲分区链表
2. 从链表中取出**第一块**分配

#### 伙伴系统

- 规定所有分区的大小均为 2 的 k 次幂。
- 当需要为进程分配大小为 n 的分区时（ $2^{i-1} < n \le 2^i$ ），在大小为 $2^i$ 的空闲分区链中查找。
  - 若找到，则分配；
  - 若找不到，则在更大一阶的**空闲分区链**中查找。
    - 若存在大小为 $2^{i+1}$ 的空闲分区，则将其等分为 2 个分区，这**大小相同、地址连续的两个分区成为一对伙伴**，其中一个用于分配，另一个加入大小为 $2^i$ 的空闲分区链中。
    - 若不存在，则继续查找，直到找到为止。回收时，也可能需要对伙伴分区进行合并。

#### [[查找#散列结构查找 (散列表、Hash 表)|哈希算法]]

根据空闲分区链表的分布规律，建立哈希函数，构建一张**以空闲分区大小为关键字的哈希表**，每个表项记录一个对应空闲分区链的头指针。分配时，根据所需分区大小，通过哈希函数计算得到哈希表中的位置，从中得到相应的空闲分区链表。
