解决运行作业时需要全部装入内存的问题

> 虚拟存储器只能采用**回写法和写分配法**，因为不能每次写命中时都同时写主存和辅存，这样效率会很低。

## 局部性原理

1. 时间局部性。程序中的某一条指令一旦执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。产生的原因是程序中存在大量的循环操作
2. 空间局部性。一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问。因为指令和数据一般都是顺序存放的。

## 请求分页管理模式

请求分页管理模式基于[[分页和分段#基本分页存储管理|基本分页存储管理]]

### 请求分页系统中的页表项

| 页号  | 物理块号 | 状态位 P       | 访问字段 A           | 修改位 M                         | 外存地址         |
| --- | ---- | ----------- | ---------------- | ----------------------------- | ------------ |
|     |      | 标记该页是否已调入内存 | 记录本页在一段时间内被访问的次数 | 标记该页在调入内存后是否被修改过，以决定换出时是否写入外存 | 记录该页在外存的存放地址 |

### 请求分页管理中的地址变换过程

![](https://img.mileomni.com/1731242858487.png)

## 页框分配

### 驻留集

驻留集是给一个[[进程]]分配的页框的集合。

- 驻留集越小，驻留在内存中的进程就越多，可以提高多道程序的并发度，但分配给每个进程的页框太少，会导致缺页率较高，CPU 需耗费大量时间来处理缺页
- 驻留集越大，由于边际效应，分配给进程的页框超过某个数目时，提升不明显，反而会浪费内存空间，还会导致多道程序并发度下降

### 工作集

工作集是指在某段时间间隔内，进程要访问的页面集合。

工作集反映了进程在接下来一段时间内很有可能会频繁访问的页面集合，因此**驻留集大小不能小于工作集**，否则进程在运行过程中会频繁缺页

![](https://img.mileomni.com/1731242858521.png)

### 内存分配策略

局部置换：若进程在运行中发生缺页，则只能从分配给该进程在内存的页面中选一页换出，然后再调入一页。（局部就是说只在进程本身的范围内换页，不会影响其他进程的空间）

全局置换：若进程在运行中发生缺页，则系统从空闲物理块队列中取出一块分配给该进程，并将所缺页调入。（全局就是说从全局的空闲空间换页）

有三种内存分配策略：

1. **固定内存局部置换**。为每个进程分配**固定数目**的物理块，在进程运行期间都不改变
2. **可变分配全局置换**。先为每个进程分配一定数目的物理块，在进程运行期间可根据情况适当地增加或减少。弊端是会盲目给进程增加物理块，导致并发能力下降
3. **可变分配局部置换**。为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出因此不会影响其他进程的运行。若进程在运行中频繁发生缺页中断，则系统为该进程再分配一些物理块，直至该进程的缺页率趋于适当程度

### 物理块调入算法

采用**固定分配**策略时，将系统中的空闲物理块分配给各个进程，可采用下述几种算法：

1. **平均分配算法**。将所有空闲物理块平均分给所有进程
2. **按比例分配算法**。按进程大小按比例分配物理块
3. **优先权分配算法**。为优先级高的进程分配更多的物理块。

通常采取的方法是将所有可分配的物理块分为两部分：一部分使用**平均分配**，一部分使用**优先权分配**。

### 调入页面的时机

- 预调页策略。根据局部性原理，预先调入不久后可能被访问的页面，但目前预测成功率仅 50%。因此这种策略主要用于进程的**首次调入**，由程序员指出调入哪些页
- 请求调页策略。当发生缺页时，提出请求，由系统将所需的页面调入内存。

### 从何处调入页面

在具有对换功能的OS中，通常把外存分为**文件区**和**对换区**。文件区用于**存放文件**，对换区用于**存放从内存换出的进程**。

- **系统拥有足够的对换区空间**。全部从对换区调入所需页面，以提高调页速度。为此，需要在程序运行前，将与该进程有关的文件从文件区复制到对换区
- **系统缺少足够的对换空间**。凡是不会被修改的文件都直接从文件区调入；可能被修改的文件，在将它们换出时必须放在对换区，以后需要时再从对换区调入（因为读比写速度快）
- UNIX **方式**。与进程有关的文件都放在文件区，因此未运行过的页面都应从文件区调入。曾经运行过但又被换出的页面，由于是放在对换区，因此在下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，测不需要再从对换区调入

## 页面置换算法

### 最佳（OPT）置换算法

最佳置换算法选择淘汰**以后最长时间内不再被访问**的页面。

![](https://img.mileomni.com/1731242858587.png)

### 先进先出（FIFO）算法

**只有**FIFO 算法会发生 Belady 异常。（为进程分配的物理块增多，缺页次数不减反增的现象）

![](https://img.mileomni.com/1731242858678.png)

### 最近未使用（LRU）算法

![](https://img.mileomni.com/1731242858719.png)

### 时钟（CLOCK）置换算法

将所有页面连接成**循环队列**的形式，循环扫描每一个页面的访问位 A 和修改位 M，换出的优先顺序如下：

1. A=0，M=0，最近未访问且未修改，是最佳的淘汰页
2. A=0，M=1，最近未访问但被修改，是次佳的淘汰页
3. A=1，M=0，最近已访问但未修改，可能再次被访问
4. A=1，M=1，最近已访问且已修改，可能再次被访问

![](https://img.mileomni.com/1731242858759.png)

实际在算法执行过程中：

1. 第一轮寻找(0,0) 的页面，**不改变访问位 A**
2. 若第一轮失败，第二轮寻找(0,1) 的页面，**将扫描过的访问位 A 置为 0**
3. 若第二轮也失败，第三轮**先将所有页面的访问位 A 都复 0**，开始重复第一步，若有必要，继续重复第二步
