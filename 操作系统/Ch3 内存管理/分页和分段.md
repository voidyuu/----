---
tags:
  - computerscience
chapter: Ch3 内存管理
subject: "[[操作系统]]"
category: "[[📖Notes]]"
aliases:
---

## 基本分段存储管理

### 段表

段表和页表的结构不同，段表的结构如下

| 段号（隐含） | 段长  | 本段在主存的始址 |
| ------ | --- | -------- |

>和页表一样，由于段表项连续存放，因此段号是隐含的，不占用存储空间。

### 地址变换机构

系统中设置一个段表寄存器，用于存放段表始址 F 和段表长度 M。从逻辑地址 A 到物理地址 E 之间的地址变换过程如下：

1. 从逻辑地址 A 中取出前几位为段号 S，后几位为段内偏移量 W
2. 判断段号是否越界，若段号 S>=段表长度 M，则产生越界中断，否则继续执行
3. 在段表中查询段号对应的段表项，段号 S 对应的段表项地址=段表始址 F+段号 S * 段表项长度。取出段表项中该段的段长 C，若 W>=C，则产生越界中断，否则继续执行
4. 取出该段表项中该段的始址 b，计算物理地址 E=b+W

![](https://img.mileomni.com/1731242853337.png)

## 基本分页存储管理

页框=页帧=物理块，都是代表**物理地址**的物理块号

分页管理不产生外部碎片，平均每个[[进程]]只产生半个块大小的内部碎片（也称页内碎片）。

页表起始地址存放在**页表基址寄存器 PTBR**中

### 地址变换机构

>页表中，由于页表项连续存放，因此页号可以是隐含的，不占用存储空间。

设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：

1. 计算页号 P=A/L、页内偏移量为 W=A%L
2. 判断页号是否越界，若页号 P>=页表长度 M，则产生越界中断，否则继续执行
3. 将页号与快表中所有页号进行比较，若存在则直接获得物理块号，若不存在则继续查询页表
4. 在页表中查询页号 P 对应的页表项。页号 P 对应的页表项地址=页表始址 F+页号 P * 页表项长度，取出该页表项内容 b，即为物理块号
5. 计算物理地址 E=b * L + W

![](https://img.mileomni.com/1731242853388.png)

### 二级页表

为了方便实现地址变换，需要在系统中增设一个**外层页表寄存器 PDBR**（也称**页目录基址寄存器**），用于存放页目录始址。

#### 二级页表地址变换过程

1. 将逻辑地址中的页目录号所谓页目录的索引，找到对应页表的始址
2. 再用二级页号作为页表分页的索引，从中找到对应的页表项
3. 将页表项中的物理块号和页内偏移量拼接，即为物理地址，再用该地址访问内存单元，共进行了 **3** 次访存。

![](https://img.mileomni.com/1731242853464.png)

## 段页式存储管理

系统为每个进程建立一张段表，每个段有一张页表。

![](https://img.mileomni.com/1731242853511.png)

## 分页和分段的对比

1. 分页是为了提高内存利用率，分页是系统的行为，对用户透明；分段需要用户自己实现，所以对用户不透明
2. 页的大小固定且由系统决定；段的长度不固定，取决于用户编写的程序
3. **分页管理的地址空间是一维的；分段管理的地址空间是二维的，因为要显式给出段号和段偏移量**。因为分页存储的页的大小是相同的。所以我们只需要提供一个逻辑地址就能够求出其所在的页号和页内偏移地址。如逻辑地址为 2049，页的大小的固定，则可以根据这一个数字求出物理地址。而分段存储的段大小是在程序员进行编程时认为设定的。如果我们只给定一个逻辑地址时。我们并不能够求出其所在的段号和段偏移量。所以可以理解为我们需要提供两个逻辑地址，分别表示其段号和段偏移量。
