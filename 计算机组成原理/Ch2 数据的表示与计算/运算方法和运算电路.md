## 程序状态字寄存器 PSW

OF：overflow，判断**有符号数**是否溢出
SF：sign，符号
ZF：zero，是否为 0
CF：carry，判断**无符号数**是否产生进/借位

## 移位运算

- 逻辑移位：左移右移都补 0
- 算数移位：左移补 0，右移补符号位，**移动后符号变了则发生溢出**

## 判断溢出

### 采用一位符号位

两个同符号数操作后结果的符号变化则溢出。

溢出逻辑表达式 $V=A_SB_S \overline S_S+\overline A_S \overline B_SS_S$

### 采用双符号位

运算结果的两个符号位相同则未溢出。
否则溢出两个符号位相同则溢出，此时最高位的符号位为真正的符号。

### 采用一位符号位根据数值位的进位情况判断

符号位的**进位**和第二位的**进位**相同则无溢出，否则有溢出。

## 加减运算电路

补码的减法将减数 $[X]_补$ 转换成 $[-X]_补$ 然后进行加法。

1. 输入端输入 $[X]_补$  后，在 MUX 多路选择器中根据 Sub 信号判断是否取**反码**
2. 若 Sub=1，则说明是减法，则取反后的值加上 Sub，实现末位+1，从而转换成 $[-X]_补$
